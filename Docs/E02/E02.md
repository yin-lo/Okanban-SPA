# S07E02 - Fetch

## Menu du jour

```
### Matin ###

- Correction Atelier 2h
  - on pense à ESLint

- Découverte `fetch` 1h
  - API Laurent + Cors + CSRF
  - Requêtes GET
  - Requêtes POST
  - Révision des body parser

### Après-midi ###

- Pratique de l'API de fetch sur Okanban
```

## Déroulé

### API S06 commune :

**Pensez à faire le npm install + fichier .env !!!**

https://github.com/O-clock-Onigiri/S07-Okanban-API-Ghislain

#### CORS Cross-origin resource sharing

Imaginons un cas, ou l'on veut que notre API ne communique qu'avec certains domaines
et ne soit donc pas accessible à tous ? Ou que certaines méthodes seulement soient possibles ?
pour que le serveur accepte les requetes de certaines origine (certains domaines)

https://developer.mozilla.org/fr/docs/Web/HTTP/CORS

```js
import cors from 'cors';
app.use(
    cors({
        //* "*" signifie que tous les sites ont accès à l'API
        origin: '*', //* plusieurs origines ['http://localhost:5500', 'http://localhost:4173']
        methods: ['GET'], // ['GET', 'PUT', 'POST', 'PATCH'] la methode `delete` ne sera pas accepter coté client
    })
);
```

#### CSRF

IMPORTANT: on va commenter la ligne `app.use(doubleCsrfProtection);`, pour ne pas utiliser le csrf
On fera la config du front ensemble lundi

**Changement à faire dans le projet pour que les call API fonctionne**

coté back => installe multer + ouvre cors origine
coté front => recup du token dans le meta, input name des forms doivent correspondre

### fetch

https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API/Using_Fetch

[Pour tester des fetchs API](https://jsonplaceholder.typicode.com)

```js
// Dans une fonction ASYNCHRONE
const response = await fetch(URL_API);
// response est une promesse qui est résolu ou rejeté
// Pour avoir les données de la réponse, je dois lui passé la méthode json()
const json = await response.json();
console.log(json);
```

Sans lui passer d'options en 2eme argument, la méthode est par défaut `GET`

On utilisera `TRY...CATCH` pour gérer les erreurs 

#### POST - bodyParser

**Coté backend (api), il faut donc rajouter le middleware suivant si on envoie du json ou du formData**

`HTML <form>` ➡️ `application/x-www-form-urlencoded`  ➡️ `app.use(express.urlencoded({ extended: true }))`
`fetch (json)` ➡️ `application/json`  ➡️ `app.use(express.json())` => Json ne traite que du texte
`fetch (FormData)` ➡️ `multipart/form-data`  ➡️ `app.use(multer().none())` => forma pour envoyer des fichiers !!

```js
const formdata = new FormData(event.target);
// event.target c'est l'élément html <form>
const response = await fetch(URL_API, {
  method: 'POST',
  body: formdata,
});
```

## Détails

<details><summary>
Détails
</summary>

## Quelques notes de cours annexes (selon contexte)

<details><summary>
Hoisting
</summary>

En JS, on peut appeler une fonction (déclarée avec `function`) au dessus de leur implémentation.
Car en fait, à la définition, la fonction n'est pas déclenché donc pas de soucis. 

</details>

<details><summary>
Spread operator (array)
</summary>

```js
const fruits = ["kiwi", "mango", "apple"];
const vegetables = ["courgette", "poivron", "aubergine"];

const foods = [...fruits, ...vegetables, "tacos"]; // ["kiwi", "mango", "apple", "courgette", "poivron", "aubergine", "tacos"];
```

</details>


